#include <TEveManager.h>
#include <TEveEventManager.h>
#include <TEveLine.h>
#include <TEveGeoNode.h>
#include <TEvePointSet.h>
#include <TFile.h>
#include <TTree.h>
#include <TMath.h>
#include <TParticle.h>
#include <TGeoManager.h>
#include <iostream>
#include <vector>
#include <TEveSelection.h>
#include <iostream>
#include <TQObject.h>
#include <NA6PMuonSpecModularHit.h>
#include <NA6PMuonSpecCluster.h>
#include <NA6PTrack.h>
#include <NA6PFastTrackFitter.h>

void ResetClusterHighlight(int );
void HighlightClusterIndex(int , int );


// ---------- GLOBALS ----------
// cluster index --> EVE object
std::vector<std::vector<TEvePointSet*>> gClusterEve;
std::vector<std::vector<Color_t>>       gClusterOrigColor;
std::vector<std::vector<Float_t>>       gClusterOrigSize;

std::vector<std::unique_ptr<NA6PMuonSpecModularHit>> gAllHits;
std::vector<std::unique_ptr<NA6PTrack>> gAllTracks;
std::vector<std::unique_ptr<NA6PBaseCluster>> gAllClusters;
std::vector<std::vector<const NA6PBaseCluster*>> gEventClusters;
std::vector<std::vector<std::unique_ptr<TParticle>>> gMCParticles;

// ------------------------------------------------------
// Define struct for various elements
// ------------------------------------------------------

enum class EveObjType { Hit, Cluster, Track };

struct EveUserData : public TObject {
    EveObjType type;
    const void* ptr;
    int event;   
    
    EveUserData(EveObjType t, const void* p, int e)
    : type(t), ptr(p), event(e) {}

ClassDef(EveUserData, 1);

};

class EvePicker : public TObject {
public:
void OnSelectionAdded(TEveElement* el)
{
    if (!el) return;

    auto* ud = static_cast<EveUserData*>(el->GetUserData());
    if (!ud) return;

    switch (ud->type) {

    case EveObjType::Hit: {
        auto* hit =
            static_cast<const NA6PMuonSpecModularHit*>(ud->ptr);
        std::cout
            << "[HIT]\n"
            << "  X = " << hit->getX()
            << "  Y = " << hit->getY()
            << "  Z = " << hit->getZ()
            << std::endl;
        break;
    }

    case EveObjType::Cluster: {
        auto* clu =
            static_cast<const NA6PBaseCluster*>(ud->ptr);
        std::cout
            << "[CLUSTER]\n"
            << "  layer = " << clu->getLayer()
            << "  size  = " << clu->getClusterSize()
            << "\n"
            << "  X = " << clu->getXLab()
            << "  Y = " << clu->getYLab()
            << "  Z = " << clu->getZLab()
            << std::endl;
        break;
    }

    case EveObjType::Track: {
//        auto* ud = static_cast<EveUserData*>(el->GetUserData());
        auto* tr =
            static_cast<const NA6PTrack*>(ud->ptr);
	int ev   = ud->event;
	    
	    double xyz[3];
	    double pxyz[3];
	    tr->getXYZ(xyz);
	    tr->getPXYZ(pxyz);
	    double p = tr->getP();
	    double pt = TMath::Sqrt(pxyz[0]*pxyz[0]+pxyz[1]*pxyz[1]);
	    double eta = -TMath::Log(pt/(p+pxyz[2])); 
	    
        std::cout << "[TRACK]\n"
	    << "  event " << ev
	    << "\n"
            << "  n_clusters = " << tr->getNHits()
	    << "\n"
            << "  track origin  X = " <<  xyz[0]
            << "  Y = " << xyz[1]
            << "  Z = " << xyz[2]
	    << "\n"
	    << "  p = " << p
	    << "  pt = " << pt
	    << "  eta = " << eta
	    << "\n"
	    << "  Particle ID = " << tr->getParticleID() 
            << std::endl;
	
        ResetClusterHighlight(ev);

        std::cout << "  Associated clusters:\n";

        for (int lr = 5; lr < 11; ++lr) {

            int ic = tr->getClusterIndex(lr);
            if (ic < 0) continue;

            HighlightClusterIndex(ev, ic);

    // retrieve cluster
            const auto* clu = gEventClusters[ev][ic];

            std::cout
                << "    layer " << clu->getLayer()
                << "  size " << clu->getClusterSize()
                << "  X " << clu->getXLab()
                << "  Y " << clu->getYLab()
                << "  Z " << clu->getZLab()
        	<< " particle ID " << clu->getParticleID()
                << "\n" ;
        }

        int n  = TMath::Abs(tr->getParticleID());

        if (ev >= 0 &&
            ev < (int)gMCParticles.size() &&
            n  >= 0 &&
            n  < (int)gMCParticles[ev].size()) {

                const TParticle* p = gMCParticles[ev][n].get();
                if(tr->getParticleID()<0) std::cout << "WARNING: at least one cluster was not generated by the following particle! " << endl; 
                std::cout
                    << "[MC PARTICLE (index = " << n << ")]\n"
                    << "  PDG = " << p->GetPdgCode()
                    << "\n"
                    << "  p = ("
                    << p->Px() << ", "
                    << p->Py() << ", "
                    << p->Pz() << ")\n"
                    << "  E = " << p->Energy()
                    << "\n"
                    << "  vtx = ("
                    << p->Vx() << ", "
                    << p->Vy() << ", "
                    << p->Vz() << ")"
                    << std::endl;
        } else {
                std::cout
                    << "[MC PARTICLE] invalid ParticleID = "
                    << n << std::endl;
        }

        std::cout << std::endl;
	
	gEve->Redraw3D(kFALSE);
	
        break;
    }
    }
}
ClassDef(EvePicker, 0);
};

void event_display_muons(int firstEv = 0, int nEv = 1,
                      const char *fgeo = "geometry.root",
		      const char *fkine = "MCKine.root",
		      const char *fhits = "HitsMuonSpecModular.root",
		      const char *fclusters = "ClustersMuonSpec.root",
		      const char *ftracks = "TracksMuonSpec.root")
{
// ------------------------------------------------------
// EVE initialization (only once)
// ------------------------------------------------------
if (!gEve) {
    TEveManager::Create();
}

// ------------------------------------------------------
// Geometry (only once)
// ------------------------------------------------------
static bool geomLoaded = false;
if (!geomLoaded) {
    TGeoManager::Import(fgeo);

    TEveGeoTopNode* geom =
        new TEveGeoTopNode(gGeoManager, gGeoManager->GetTopNode());
    geom->SetPickableRecursively(kFALSE);
    gEve->AddGlobalElement(geom);

    geomLoaded = true;
}


// ------------------------------------------------------
// Clear previous event
// ------------------------------------------------------
if (gEve->GetCurrentEvent()) {
    gEve->GetCurrentEvent()->DestroyElements();
}

// ------------------------------------------------------
// Create NEW event manager
// ------------------------------------------------------
TEveEventManager* ev =
    new TEveEventManager("Event", "NA6 event");
gEve->AddEvent(ev);
gEve->SetCurrentEvent(ev);

// ------------------------------------------------------
// Clear your persistent storage
// ------------------------------------------------------
gAllHits.clear();
gAllTracks.clear();
gAllClusters.clear();
gEventClusters.clear();

gClusterEve.clear();
gClusterOrigColor.clear();
gClusterOrigSize.clear();

gMCParticles.clear();

static EvePicker* gPicker = new EvePicker;

gEve->GetSelection()->Disconnect(
    "SelectionAdded(TEveElement*)",
    gPicker,
    "OnSelectionAdded(TEveElement*)"
);
gEve->GetSelection()->Connect(
    "SelectionAdded(TEveElement*)",
    "EvePicker",
    gPicker,
    "OnSelectionAdded(TEveElement*)"
);

// Enable selection
gEve->GetSelection()->SetPickToSelect(kTRUE);

// Load kine
TFile* fk=new TFile(fkine);
TTree* tk=(TTree*)fk->Get("mckine");

std::vector<TParticle>* mcArr = nullptr;
tk->SetBranchAddress("tracks", &mcArr);

// Load hits
TFile* f = TFile::Open(fhits);
TTree* t = (TTree*)f->Get("hitsMuonSpecModular");

std::vector<NA6PMuonSpecModularHit> msHits;
std::vector<NA6PMuonSpecModularHit>* msHitsPtr = &msHits;
t->SetBranchAddress("MuonSpecModular", &msHitsPtr);

// Load clusters
TFile* fc = TFile::Open(fclusters);
TTree* tc = (TTree*)fc->Get("clustersMuonSpec");

std::vector<NA6PMuonSpecCluster> clusters;
std::vector<NA6PMuonSpecCluster>* clustersPtr = &clusters;
tc->SetBranchAddress("MuonSpec", &clustersPtr);

// Load tracks

TFile* ft=new TFile(ftracks);
TTree* tt=(TTree*)ft->Get("tracksMuonSpec");

std::vector<NA6PTrack> msTracks, *msTracksPtr = &msTracks;
tt->SetBranchAddress("MuonSpec", &msTracksPtr);

for (int iEv = firstEv; iEv < firstEv + nEv; iEv++) {

    int evIdx = iEv - firstEv;

    t->GetEntry(iEv);
    tc->GetEntry(iEv);
    tt->GetEntry(iEv);
    tk->GetEntry(iEv);
    
    gClusterEve.emplace_back();
    gClusterOrigColor.emplace_back();
    gClusterOrigSize.emplace_back();
    gEventClusters.emplace_back();
    gMCParticles.emplace_back();

    auto& mcEv = gMCParticles.back();

    for (const auto& p : *mcArr) {
    mcEv.emplace_back(
        std::make_unique<TParticle>(p)
    );
    }

    int nhit=0;
    for (auto& h : msHits) {
     
        gAllHits.emplace_back(
            std::make_unique<NA6PMuonSpecModularHit>(h)
        );
        
        auto* hitPtr = gAllHits.back().get();
    
        auto* hitEve = new TEvePointSet(1);
        hitEve->SetNextPoint(h.getX(), h.getY(), h.getZ());
        hitEve->SetMarkerStyle(4);
        hitEve->SetMarkerSize(1.5);
        hitEve->SetMarkerColor(kRed);
        hitEve->SetPickable(kTRUE);

        // Attach the hit itself
        hitEve->SetUserData(
        new EveUserData(EveObjType::Hit, hitPtr, evIdx)
        );

        gEve->AddElement(hitEve);

        nhit++;
    }

    for (auto& c : clusters) {

        // Persistent copy
        gAllClusters.emplace_back(
            std::make_unique<NA6PMuonSpecCluster>(c)
        );
        auto* cluPtr = gAllClusters.back().get();

        // EVE object
        auto* eveClu = new TEvePointSet(1);
        eveClu->SetNextPoint(
            cluPtr->getXLab(),
            cluPtr->getYLab(),
            cluPtr->getZLab()
        );

        eveClu->SetName(Form("Cluster L%d", cluPtr->getLayer()));
        eveClu->SetMarkerStyle(20);
        eveClu->SetMarkerSize(3.);
        eveClu->SetMarkerColor(kGreen+2);
        eveClu->SetPickable(kTRUE);

        // EVENT-LOCAL INDEXING
        gEventClusters[evIdx].push_back(cluPtr);

        // Attach cluster
        eveClu->SetUserData(
        new EveUserData(EveObjType::Cluster, cluPtr, evIdx)
        );
	
	gClusterEve[evIdx].push_back(eveClu);
        gClusterOrigColor[evIdx].push_back(eveClu->GetMarkerColor());
        gClusterOrigSize[evIdx].push_back(eveClu->GetMarkerSize());
  
        gEve->AddElement(eveClu);
    }

    cout << " Number of reconstructed tracks " <<  msTracks.size() << endl;
    
    for(auto& track : msTracks) {
    
        gAllTracks.emplace_back(std::make_unique<NA6PTrack>(track));
        auto* trPtr = gAllTracks.back().get();

        TEveLine *eveTrack = new TEveLine();
        eveTrack->SetLineColor(kBlue);
        eveTrack->SetLineWidth(2);
        eveTrack->SetPickable(kTRUE);
    
        double xyz[3];
        track.getXYZ(xyz);
        NA6PFastTrackFitter fitter;
        for(int np=0;np<850;np++){
          fitter.propagateToZ(&track,0.+np);
          eveTrack->SetNextPoint(track.getXLab(), track.getYLab(), track.getZLab());
        }

        eveTrack->SetUserData(
        new EveUserData(EveObjType::Track, trPtr, evIdx)
        );

        gEve->AddElement(eveTrack);
    }

    gEve->Redraw3D(kTRUE);

}

}

void ResetClusterHighlight(int ev)
{
    for (size_t i = 0; i < gClusterEve[ev].size(); ++i) {
        gClusterEve[ev][i]->SetMarkerColor(gClusterOrigColor[ev][i]);
        gClusterEve[ev][i]->SetMarkerSize(gClusterOrigSize[ev][i]);
    }
}

void HighlightClusterIndex(int ev, int idx)
{
    if (ev < 0 || ev >= (int)gClusterEve[ev].size()) return;
    if (idx < 0 || idx >= (int)gClusterEve[ev].size()) return;

    gClusterEve[ev][idx]->SetMarkerColor(kYellow);
    gClusterEve[ev][idx]->SetMarkerSize(2.5);
}

